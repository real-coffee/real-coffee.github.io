<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>블록 아트 생성기 (Slack 이모지 shortcode 모드 지원)</title>
  <style>
    :root { --bg:#f7f7fb; --card:#ffffff; --ink:#111827; --muted:#6b7280; --brand:#4f46e5; }
    *{box-sizing:border-box}
    body{margin:0; font-family: system-ui,-apple-system,Segoe UI,Roboto,"Noto Sans KR","Apple SD Gothic Neo","Malgun Gothic",Arial,sans-serif; background:var(--bg); color:var(--ink)}
    .wrap{max-width:1024px; margin:0 auto; padding:24px}
    .card{background:var(--card); border-radius:16px; box-shadow:0 10px 30px rgba(0,0,0,.06); padding:16px}
    h1{font-size:clamp(20px,3vw,28px); margin:0 0 8px}
    p.small{color:var(--muted); margin:0 0 16px; font-size:13px}
    .grid{display:grid; gap:12px; grid-template-columns:1fr}
    @media (min-width:768px){ .grid-3{ grid-template-columns:repeat(3,1fr)} }
    .row{display:grid; gap:6px}
    label{font-size:13px; color:var(--muted)}
    input[type="text"], input[type="number"], button, select{height:40px}
    input[type="text"], input[type="number"], select{width:100%; border:1px solid #e5e7eb; border-radius:10px; padding:0 12px; background:#fff; outline:none; transition: box-shadow .15s,border-color .15s}
    input[type="text"]:focus, input[type="number"]:focus, select:focus{border-color:var(--brand); box-shadow:0 0 0 3px rgba(79,70,229,.15)}
    input[type="range"]{width:100%}
    .controls{display:flex; flex-wrap:wrap; gap:8px; align-items:center}
    .btn{border:0; background:var(--brand); color:#fff; border-radius:10px; padding:0 12px; cursor:pointer}
    .btn:hover{filter:brightness(.95)}
    .btn-ghost{background:#eef2ff; color:#3730a3}
    .mono{white-space:pre; overflow:auto; background:#0b1020; color:#e5e7eb; border-radius:12px; padding:12px; line-height:1em; font-family: ui-monospace,Menlo,Monaco,Consolas,'Liberation Mono','Courier New',monospace}
    .hint{font-size:12px; color:var(--muted)}
    .row-inline{display:flex; gap:10px; align-items:center; flex-wrap:wrap}
    .switch{display:inline-flex; gap:6px; align-items:center; font-size:13px}
    .footer{color:var(--muted); font-size:12px; margin-top:8px}
    .muted{color:var(--muted); font-size:12px}
  </style>
</head>
<body>
  <div class="wrap">
    <div class="card">
      <div class="row-inline" style="justify-content:space-between;">
        <h1>블록 아트 생성기 – Slack 이모지(shortcode) 아스키 아트</h1>
        <div class="controls">
          <button class="btn btn-ghost" id="presetPc" title="PC 해상도 프리셋">PC(64)</button>
          <button class="btn btn-ghost" id="presetMo" title="모바일 해상도 프리셋">Mobile(20)</button>
        </div>
      </div>
      <p class="small">입력 텍스트를 캔버스에 렌더링해 샘플링한 뒤, 각 셀을 <b>공백과 Slack 이모지 shortcode</b>(예: <code>:thumbsy2:</code>)로만 출력합니다. 그대로 복사→Slack에 붙여넣으면 블록 아트처럼 보입니다.</p>

      <div class="grid grid-3">
        <div class="row">
          <label>텍스트</label>
          <input type="text" id="text" placeholder="예: 따 / Hello / 안녕" value="따" />
          <div class="hint">둘 이상 글자는 해상도(가로 블록 수)를 올리면 윤곽이 또렷합니다.</div>
        </div>
        <div class="row">
          <label>가로 블록 수: <span id="colsVal">64</span></label>
          <input type="range" id="cols" min="8" max="160" value="64" />
          <div class="hint">모바일 8–24 권장. 화면이 좁을수록 낮추세요.</div>
        </div>
        <div class="row">
          <label>감도(임계값): <span id="thVal">140</span></label>
          <input type="range" id="th" min="40" max="220" value="140" />
          <div class="hint">낮을수록 더 진하게 채워집니다.</div>
        </div>
      </div>

      <div class="grid" style="grid-template-columns:1fr 1fr 1fr;">
        <div class="row">
          <label>이모지 shortcode</label>
          <input type="text" id="fg" value=":thumbsy2:" />
          <div class="hint">예: <code>:thumbsy2:</code>, <code>:fire:</code>, <code>:rocket:</code> 등. 그대로 출력됩니다.</div>
        </div>
        <div class="row">
          <label>셀 폭(칸)</label>
          <input type="number" id="cellCols" min="1" max="20" value="6" />
          <div class="hint">한 셀이 Slack에서 차지하길 원하는 총 칸(문자) 폭. 예: 6</div>
        </div>
        <div class="row">
          <label>이모지 가정 폭(칸)</label>
          <input type="number" id="glyphCols" min="0" max="20" value="5" />
          <div class="hint">Slack에서 해당 이모지의 대략적 폭(예: 5 또는 6). 남는 칸은 공백으로 우측 패딩.</div>
        </div>
      </div>

      <div class="grid" style="grid-template-columns:1fr 1fr;">
        <div class="row">
          <label>세로 반복(줄)</label>
          <input type="number" id="cellRows" min="1" max="4" value="1" />
          <div class="hint">한 셀(한 줄)을 수직으로 복제하여 종횡비를 조정</div>
        </div>
        <div class="row">
          <label class="switch"><input type="checkbox" id="bold" checked> 굵게(bold, 렌더링용)</label>
          <label class="switch">줄 간격(빈 줄): <input type="number" id="linespace" min="0" max="3" value="0" style="width:64px"></label>
          <label class="switch">폰트:
            <select id="fontSel">
              <option value="Apple SD Gothic Neo,Malgun Gothic,Noto Sans KR,Arial Unicode MS,sans-serif">한글 가독성</option>
              <option value="Noto Sans KR,Apple SD Gothic Neo,Malgun Gothic,Arial Unicode MS,sans-serif">Noto Sans KR</option>
              <option value="Segoe UI,Roboto,system-ui,sans-serif">영문 위주</option>
              <option value="ui-monospace,Menlo,Monaco,Consolas,'Liberation Mono','Courier New',monospace">Monospace</option>
            </select>
          </label>
        </div>
      </div>

      <div class="controls" style="margin:8px 0; gap:12px;">
        <button class="btn" id="copyBtn">결과 복사</button>
        <button class="btn" id="downloadBtn">.txt 저장</button>
      </div>

      <div class="row">
        <label>결과 (공백+shortcode만 포함)</label>
        <pre id="out" class="mono" style="min-height:160px;">(여기에 결과가 표시됩니다)</pre>
      </div>

      <canvas id="hiddenCanvas" width="1" height="1" style="display:none"></canvas>
      <div class="footer">주의: Slack/OS/폰트에 따라 이모지 가로폭이 달라 보일 수 있습니다. <b>이모지 가정 폭</b>을 조절해 실제 결과에 맞춰보세요. 출력은 항상 "공백 + :emoji_name:"만 사용합니다.</div>
    </div>
  </div>

  <script>
    const $ = sel => document.querySelector(sel);
    const text = $('#text');
    const cols = $('#cols');
    const colsVal = $('#colsVal');
    const th = $('#th');
    const thVal = $('#thVal');
    const fg = $('#fg');
    const bold = $('#bold');
    const linespace = $('#linespace');
    const out = $('#out');
    const fontSel = $('#fontSel');
    const canvas = $('#hiddenCanvas');
    const presetPc = $('#presetPc');
    const presetMo = $('#presetMo');
    const copyBtn = $('#copyBtn');
    const downloadBtn = $('#downloadBtn');

    const cellCols = $('#cellCols');
    const glyphCols = $('#glyphCols');
    const cellRows = $('#cellRows');

    // 초기값: 모바일이면 20, PC면 64
    if (window.innerWidth < 640) cols.value = 20;
    colsVal.textContent = cols.value;
    thVal.textContent = th.value;

    function buildCell(isFilled){
      const total = Math.max(1, parseInt(cellCols.value||'6', 10));
      const assumed = Math.max(0, parseInt(glyphCols.value||'5', 10));
      if (isFilled){
        const token = fg.value || ':emoji:'; // 그대로 출력
        const pad = Math.max(0, total - assumed);
        return token + ' '.repeat(pad);
      } else {
        return ' '.repeat(total);
      }
    }

    function render(){
      const ctx = canvas.getContext('2d', { willReadFrequently:true });
      const txt = text.value || '';
      const threshold = parseInt(th.value, 10) || 140;
      const weight = bold.checked ? 800 : 400;
      const font = fontSel.value;

      if (!txt.trim()) { out.textContent = ''; return; }

      // 캔버스 렌더링 (윤곽 추출 전용)
      const baseFontSize = 240;
      ctx.font = `${weight} ${baseFontSize}px ${font}`;
      const metrics = ctx.measureText(txt);
      const textWidth = Math.ceil(metrics.width) + 40;
      const ascent = Math.ceil(metrics.actualBoundingBoxAscent || baseFontSize*0.8);
      const descent = Math.ceil(metrics.actualBoundingBoxDescent || baseFontSize*0.2);
      const textHeight = ascent + descent + 40;

      canvas.width = Math.max(1, textWidth);
      canvas.height = Math.max(1, textHeight);
      ctx.fillStyle = '#ffffff';
      ctx.fillRect(0,0,canvas.width,canvas.height);
      ctx.fillStyle = '#000000';
      ctx.textBaseline = 'alphabetic';
      ctx.font = `${weight} ${baseFontSize}px ${font}`;
      ctx.fillText(txt, 20, 20+ascent);

      const COLS = Math.max(1, parseInt(cols.value,10) || 64);
      const ROWS = Math.max(1, Math.round((canvas.height/canvas.width) * COLS));

      const img = ctx.getImageData(0,0,canvas.width,canvas.height).data;
      const cellW = canvas.width / COLS;
      const cellH = canvas.height / ROWS;

      const filledCell = buildCell(true);
      const emptyCell = buildCell(false);

      const lines = [];
      for (let r=0; r<ROWS; r++){
        let line = '';
        for (let c=0; c<COLS; c++){
          const x0 = Math.floor(c*cellW);
          const y0 = Math.floor(r*cellH);
          const x1 = Math.min(canvas.width, Math.floor((c+1)*cellW));
          const y1 = Math.min(canvas.height, Math.floor((r+1)*cellH));
          let sum=0, cnt=0;
          for (let y=y0; y<y1; y++){
            for (let x=x0; x<x1; x++){
              const idx = (y*canvas.width + x)*4;
              const lum = (img[idx]+img[idx+1]+img[idx+2])/3; // 평균 명도
              sum += lum; cnt++;
            }
          }
          const avg = cnt ? sum/cnt : 255;
          line += (avg < threshold) ? filledCell : emptyCell;
        }
        const vr = Math.max(1, Math.min(4, parseInt(cellRows.value||'1',10)));
        for (let k=0; k<vr; k++) lines.push(line);
        const extra = Math.max(0, Math.min(3, parseInt(linespace.value||'0',10)));
        for (let k=0; k<extra; k++) lines.push('');
      }
      while (lines.length && lines[0].trim().length===0) lines.shift();
      while (lines.length && lines[lines.length-1].trim().length===0) lines.pop();

      out.textContent = lines.join('
');
      colsVal.textContent = COLS;
      thVal.textContent = threshold;
    }

    [text, cols, th, fg, bold, linespace, fontSel, cellCols, glyphCols, cellRows].forEach(el => el.addEventListener('input', render));

    window.addEventListener('resize', () => {});
    presetPc.addEventListener('click', () => { cols.value = 64; render(); });
    presetMo.addEventListener('click', () => { cols.value = 20; render(); });

    copyBtn.addEventListener('click', async () => {
      try { await navigator.clipboard.writeText(out.textContent || ''); } catch(e) { alert('클립보드 복사 실패: '+e); }
    });
    downloadBtn.addEventListener('click', () => {
      const blob = new Blob([out.textContent||''], {type:'text/plain;charset=utf-8'});
      const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = 'block-art.txt';
      document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(a.href);
    });

    // 초기 렌더
    render();
  </script>
</body>
</html>
